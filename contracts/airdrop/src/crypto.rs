use astroport_periphery::airdrop::SignatureResponse;
use cosmwasm_std::{Api, StdError, StdResult, Uint128};
use sha3::{Digest, Keccak256};
use std::cmp::Ordering;
use std::convert::TryInto;

/// @dev Verify whether a claim is valid
/// @param account Account on behalf of which the airdrop is to be claimed (etherum addresses without `0x` prefix)
/// @param amount Airdrop amount to be claimed by the user
/// @param merkle_proof Array of hashes to prove the input is a leaf of the Merkle Tree
/// @param merkle_root Hash of Merkle tree's root
pub fn verify_claim(
    account: String,
    amount: Uint128,
    merkle_proof: Vec<String>,
    merkle_root: &str,
) -> bool {
    let leaf = account + &amount.to_string();
    let mut hash_buf = Keccak256::digest(leaf.as_bytes())
        .as_slice()
        .try_into()
        .expect("Wrong length");
    let mut hash_str: String;

    for p in merkle_proof {
        let mut proof_buf: [u8; 32] = [0; 32];
        hex::decode_to_slice(p, &mut proof_buf).unwrap();
        let proof_buf_str = hex::encode(proof_buf);
        hash_str = hex::encode(hash_buf);

        if proof_buf_str.cmp(&hash_str.clone()) == Ordering::Greater {
            hash_buf = Keccak256::digest(&[hash_buf, proof_buf].concat())
                .as_slice()
                .try_into()
                .expect("Wrong length")
        } else {
            hash_buf = Keccak256::digest(&[proof_buf, hash_buf].concat())
                .as_slice()
                .try_into()
                .expect("Wrong length")
        }
    }

    hash_str = hex::encode(hash_buf);
    merkle_root == hash_str
}

/// @dev Verify whether Signature provided is valid
/// @param evm_address : EVM address claiming to have signed the message. Needs to be in lower case without the `0x` prefix
/// @param evm_signature : ECDSA Signature string generated by signing the message (without the `0x` prefix and the last 2 characters which originate from `v`)
/// @param signed_msg_hash : Keccak256 hash of the signed message following the EIP-191 prefix standard.(without the `0x` prefix)
pub fn handle_verify_signature(
    api: &dyn Api,
    evm_address: String,
    evm_signature: String,
    signed_msg_hash: String,
) -> SignatureResponse {
    let msg_hash = hex::decode(signed_msg_hash).unwrap();
    let signature = hex::decode(evm_signature).unwrap();
    let recovery_param = normalize_recovery_id(signature[63]);

    let recovered_public_key = api
        .secp256k1_recover_pubkey(&msg_hash, &signature, recovery_param)
        .unwrap_or_else(|_| [].to_vec());

    let recovered_public_key_string = hex::encode(&recovered_public_key);

    let recovered_address = evm_address_raw(&recovered_public_key).unwrap_or([0; 20]);
    let recovered_address_string = hex::encode(recovered_address);

    SignatureResponse {
        is_valid: evm_address == recovered_address_string,
        public_key: recovered_public_key_string,
        recovered_address: recovered_address_string,
    }
}

/// Returns a raw 20 byte Ethereum address
/// Copied from https://github.com/CosmWasm/cosmwasm/blob/96a1f888f0cdb7446e29f60054165e635b258e39/contracts/crypto-verify/src/ethereum.rs#L99
pub fn evm_address_raw(pubkey: &[u8]) -> StdResult<[u8; 20]> {
    let (tag, data) = match pubkey.split_first() {
        Some(pair) => pair,
        None => return Err(StdError::generic_err("Public key must not be empty")),
    };
    if *tag != 0x04 {
        return Err(StdError::generic_err("Public key must start with 0x04"));
    }
    if data.len() != 64 {
        return Err(StdError::generic_err("Public key must be 65 bytes long"));
    }

    let hash = Keccak256::digest(data);
    Ok(hash[hash.len() - 20..].try_into().unwrap())
}

/// Normalizes recovery id for recoverable signature while getting the recovery param from the value `v`
/// See [EIP-155] for how `v` is composed.
/// [EIP-155]: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md
/// Copied from https://github.com/gakonst/ethers-rs/blob/01cc80769c291fc80f5b1e9173b7b580ae6b6413/ethers-core/src/types/signature.rs#L142
pub fn normalize_recovery_id(v: u8) -> u8 {
    match v {
        0 => 0,
        1 => 1,
        27 => 0,
        28 => 1,
        v if v >= 35 => ((v - 1) % 2) as _,
        _ => 4,
    }
}
